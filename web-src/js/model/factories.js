// Generated by CoffeeScript 1.12.5
var ERDFactory, Factory, UMLFactory, erd, exports, uml,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

uml = joint.shapes.uml;

erd = joint.shapes.erd;

Factory = (function() {
  function Factory() {}

  Factory.prototype.create_class = function(name) {};

  Factory.prototype.create_association = function(class_a_id, class_b_id, name) {
    if (name == null) {
      name = null;
    }
  };

  return Factory;

})();

UMLFactory = (function(superClass) {
  extend(UMLFactory, superClass);

  function UMLFactory() {}

  UMLFactory.prototype.create_class = function(class_name, attribs, methods, css_class) {
    var newclass, params;
    if (css_class == null) {
      css_class = null;
    }
    console.log(attribs);
    console.log(methods);
    params = {
      position: {
        x: 20,
        y: 20
      },
      size: {
        width: 220,
        height: 100
      },
      name: class_name,
      attributes: attribs,
      methods: methods,
      attrs: {
        '.uml-class-name-rect': {
          fill: '#ff8450',
          stroke: '#fff'
        },
        '.uml-class-name-text': {
          fill: '#000000'
        }
      }
    };
    if (css_class != null) {
      params.attrs = css_class;
    }
    newclass = new uml.Class(params);
    return newclass;
  };

  UMLFactory.prototype.create_association = function(class_a_id, class_b_id, name, css_links, mult, roles) {
    var labels, link, str_labels;
    if (name == null) {
      name = null;
    }
    if (css_links == null) {
      css_links = null;
    }
    if (mult == null) {
      mult = null;
    }
    if (roles == null) {
      roles = null;
    }
    link = new joint.dia.Link({
      source: {
        id: class_a_id
      },
      target: {
        id: class_b_id
      },
      attrs: css_links
    });
    str_labels = [null, null, null];
    if (roles !== null) {
      if (roles[0] !== null) {
        str_labels[0] = roles[0];
      }
      if (roles[1] !== null) {
        str_labels[2] = roles[1];
      }
    }
    if (mult !== null) {
      if (mult[0] !== null) {
        if (str_labels[0] !== null) {
          str_labels[0] += "\n" + mult[0];
        } else {
          str_labels[0] = mult[0];
        }
      }
      if (mult[1] !== null) {
        if (str_labels[2] !== null) {
          str_labels[2] += "\n" + mult[1];
        } else {
          str_labels[2] = mult[1];
        }
      }
    }
    str_labels[1] = name;
    labels = [];
    if (str_labels[1] !== null) {
      labels[1] = {
        position: 0.5,
        attrs: {
          text: {
            text: str_labels[1],
            fill: '#0000ff'
          },
          rect: {
            fill: '#ffffff'
          }
        }
      };
    }
    if (str_labels[0] !== null) {
      labels[0] = {
        position: 0.1,
        attrs: {
          text: {
            text: str_labels[0],
            fill: '#0000ff'
          },
          rect: {
            fill: '#ffffff'
          }
        }
      };
    }
    if (str_labels[2] !== null) {
      labels[2] = {
        position: 0.9,
        attrs: {
          text: {
            text: str_labels[2],
            fill: '#0000ff'
          },
          rect: {
            fill: '#ffffff'
          }
        }
      };
    }
    link.set({
      labels: labels
    });
    return link;
  };

  UMLFactory.prototype.create_generalization = function(class_a_id, class_b_id, css_links, disjoint, covering) {
    var labels, legend, link;
    if (css_links == null) {
      css_links = null;
    }
    if (disjoint == null) {
      disjoint = false;
    }
    if (covering == null) {
      covering = false;
    }
    labels = [];
    link = new joint.shapes.uml.Generalization({
      source: {
        id: class_b_id
      },
      target: {
        id: class_a_id
      },
      attrs: css_links
    });
    if (disjoint || covering) {
      legend = "{";
      if (disjoint) {
        legend = legend + "disjoint";
      }
      if (covering) {
        if (legend !== "") {
          legend = legend + ",";
        }
        legend = legend + "covering";
      }
      legend = legend + "}";
    }
    labels = labels.concat([
      {
        position: 0.8,
        attrs: {
          text: {
            text: legend,
            fill: '#0000ff'
          },
          rect: {
            fill: '#ffffff'
          }
        }
      }
    ]);
    link.set({
      labels: labels
    });
    return link;
  };

  UMLFactory.prototype.create_association_class = function(class_name, css_class) {
    if (css_class == null) {
      css_class = null;
    }
    return this.create_class(class_name, css_class);
  };

  return UMLFactory;

})(Factory);

ERDFactory = (function(superClass) {
  extend(ERDFactory, superClass);

  function ERDFactory() {}

  ERDFactory.prototype.create_class = function(class_name, css_class) {
    var newclass, params;
    if (css_class == null) {
      css_class = null;
    }
    params = {
      position: {
        x: 20,
        y: 20
      },
      attrs: {
        text: {
          fill: "#ffffff",
          text: class_name,
          'letter-spacing': 0,
          style: {
            'text-shadow': '1px 0 1px #333333'
          }
        },
        '.outer, .inner': {
          fill: '#31d0c6',
          stroke: 'none',
          filter: {
            name: 'dropShadow',
            args: {
              dx: 0.5,
              dy: 2,
              blur: 2,
              color: '#333333'
            }
          }
        }
      }
    };
    newclass = new erd.Entity(params);
    return newclass;
  };

  ERDFactory.prototype.create_attribute = function(attr_name, attr_type, css_class) {
    var newattribute;
    if (css_class == null) {
      css_class = null;
    }
    if (attr_type === 'key') {
      newattribute = new erd.Key({
        position: {
          x: 200,
          y: 10
        },
        attrs: {
          text: {
            fill: '#ffffff',
            text: attr_name
          }
        }
      });
    } else {
      newattribute = new erd.Normal({
        position: {
          x: 150,
          y: 150
        },
        attrs: {
          text: {
            fill: '#ffffff',
            text: attr_name,
            style: {
              'text-shadow': '1px 0 1px #333333'
            }
          }
        }
      });
    }
    return newattribute;
  };

  ERDFactory.prototype.create_link_attribute = function(class_name, attr_name) {
    var markup_style, myLink;
    markup_style = ['<path class="connection" stroke="black" d="M 0 0 0 0"/>', '<path class="connection-wrap" d="M 0 0 0 0"/>', '<g class="labels"/>', '<g class="marker-vertices"/>', '<g class="marker-arrowheads"/>'];
    myLink = new erd.Line({
      markup: markup_style.join(''),
      source: {
        id: attr_name
      },
      target: {
        id: class_name
      }
    });
    return myLink;
  };

  ERDFactory.prototype.create_generalization = function(class_a_id, class_b_id, css_links, disjoint, covering) {
    var isaattr, labels, legend, link;
    if (css_links == null) {
      css_links = null;
    }
    if (disjoint == null) {
      disjoint = false;
    }
    if (covering == null) {
      covering = false;
    }
    labels = [];
    isaattr = {
      text: {
        text: 'ISA',
        fill: '#ffffff',
        'letter-spacing': 0,
        style: {
          'text-shadow': '1px 0 1px #333333'
        }
      },
      polygon: {
        fill: '#fdb664',
        stroke: 'none',
        filter: {
          name: 'dropShadow',
          args: {
            dx: 0,
            dy: 2,
            blur: 1,
            color: '#333333'
          }
        }
      }
    };
    link = new erd.ISA({
      position: {
        x: 125,
        y: 200
      },
      attrs: isaattr
    });
    if (disjoint || covering) {
      legend = "{";
      if (disjoint) {
        legend = legend + "disjoint";
      }
      if (covering) {
        if (legend !== "") {
          legend = legend + ",";
        }
        legend = legend + "covering";
      }
      legend = legend + "}";
    }
    labels = labels.concat([
      {
        position: 0.8,
        attrs: {
          text: {
            text: legend,
            fill: '#0000ff'
          },
          rect: {
            fill: '#ffffff'
          }
        }
      }
    ]);
    link.set({
      labels: labels
    });
    return link;
  };

  return ERDFactory;

})(Factory);

exports = exports != null ? exports : this;

exports.Factory = Factory;

exports.UMLFactory = UMLFactory;

exports.ERDFactory = ERDFactory;
